= Introduction to Moq =

Moq is intended to be simple to use, strong typed (no magic strings!) and therefore full compiler-verified and refactoring-friendly.


= Examples =

{{{
// ShouldExpectCallReturn
var mock = new Mock<ICloneable>();
var clone = new object();

mock.Expect(x => x.Clone()).Returns(clone);

Assert.AreEqual(clone, mock.Value.Clone());
}}}

{{{
// ShouldExpectCallWithArgument
var mock = new Mock<IFoo>();

mock.Expect(x => x.DoInt(1)).Returns(11);
mock.Expect(x => x.DoInt(2)).Returns(22);

Assert.AreEqual(11, mock.Value.DoInt(1));
Assert.AreEqual(22, mock.Value.DoInt(2));
}}}

{{{
// ShouldExpectCallWithReferenceLazyEvaluate
int a = 25;
var mock = new Mock<IFoo>();
mock.Expect(x => x.DoArgument(a.ToString())).Returns(() => a);
a = 10;

Assert.AreEqual(10, mock.Value.DoArgument("10"));
}}}

{{{
// ShouldExpectReturnPropertyValue
var mock = new Mock<IFoo>();

mock.Expect(x => x.ValueProperty).Returns(25);

Assert.AreEqual(25, mock.Value.ValueProperty);
}}}

{{{
// ShouldExpectMethodCallWithVariable
int value = 5;
var mock = new Mock<IFoo>();

mock.Expect(x => x.Duplicate(value)).Returns(() => value * 2);

Assert.AreEqual(value * 2, mock.Value.Duplicate(value));
}}}

{{{
// ShouldMatchAnyArgument
var mock = new Mock<IFoo>();

mock.Expect(x => x.Duplicate(It.IsAny<int>())).Returns(() => 5);

Assert.AreEqual(5, mock.Value.Duplicate(5));
Assert.AreEqual(5, mock.Value.Duplicate(25));
}}}

{{{
// ShouldMatchPredicateArgument
var mock = new Mock<IFoo>();

mock.
	Expect(x => x.Duplicate(It.Is<int>(value => value < 5 && value > 0))).
	Returns(() => 1);

Assert.AreEqual(1, mock.Value.Duplicate(3));
Assert.AreEqual(0, mock.Value.Duplicate(0));
}}}

{{{
// ShouldExpectCallWithoutReturnValue
var mock = new Mock<IFoo>();

mock.Expect(x => x.Execute());

mock.Value.Execute();
}}}

{{{
// ShouldThrowIfExpectingThrows
var mock = new Mock<IFoo>();

mock.Expect(x => x.Do1()).Throws(new FormatException());

mock.Value.Do1();
}}}

{{{
// ShouldExecuteCallbackWhenVoidMethodIsCalled
var mock = new Mock<IFoo>();
bool called = false;
mock.Expect(x => x.Execute()).Callback(() => called = true);

mock.Value.Execute();
Assert.IsTrue(called);
}}}

{{{
// ShouldExecuteCallbackWhenNonVoidMethodIsCalled
var mock = new Mock<IFoo>();
bool called = false;
mock.Expect(x => x.Do1()).Callback(() => called = true).Returns(1);

Assert.AreEqual(1, mock.Value.Do1());
Assert.IsTrue(called);
}}}

{{{
// ShouldExpectRanges
var mock = new Mock<IFoo>();

mock.Expect(x => x.DoInt(It.IsInRange(1, 5, Range.Inclusive))).Returns(1);
mock.Expect(x => x.DoInt(It.IsInRange(6, 10, Range.Exclusive))).Returns(2);

Assert.AreEqual(1, mock.Value.DoInt(1));
Assert.AreEqual(1, mock.Value.DoInt(2));
Assert.AreEqual(1, mock.Value.DoInt(5));

Assert.AreEqual(2, mock.Value.DoInt(7));
Assert.AreEqual(2, mock.Value.DoInt(9));
}}}

*Note*: the required `mock.Value` accessor is a consequence of a C# compiler restriction (vote to get it removed [https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=318122 at Microsoft Connect])
#labels Featured
= Introduction to Moq =

Moq is intended to be simple to use, strong typed (no magic strings!, and therefore full compiler-verified and refactoring-friendly) and minimalistic.

== Methods ==

{{{
var mock = new Mock<IFoo>();
mock.Expect(foo => foo.Execute("ping")).Returns(true);


// out arguments
var outString = "ack";
// TryParse will return true, and the out argument will return "ack", lazy evaluated
mock.Expect(foo => foo.TryParse("ping", out outString)).Returns(true);


// ref arguments
var instance = new Bar();
// Only matches if the ref argument to the invocation is the same instance
mock.Expect(foo => foo.Submit(ref instance)).Returns(true);


// access invocation arguments
mock.Expect(x => x.Execute(It.IsAny<string>()))
		.Returns((string s) => s.ToLower());


// throwing when invoked
mock.Expect(foo => foo.Execute("reset")).Throws<InvalidOperationException>();
mock.Expect(foo => foo.Execute("")).Throws(new ArgumentException("command");


// lazy evaluating return value
mock.Expect(foo => foo.Count()).Returns(() => count);


// returning different values on each invocation
var mock = new Mock<IFoo>();
var calls = 0;
mock.Expect(foo => foo.Execute("ping"))
    .Returns(() => calls)
    .Callback(() => calls++);
// returns 0 on first invocation, 1 on the next, and so on
Console.WriteLine(mock.Object.Execute("ping"));

}}}

== Matching Arguments ==

{{{
// any value
mock.Expect(foo => foo.Execute(It.IsAny<string>())).Returns(true);


// matching Func<int>, lazy evaluated
mock.Expect(foo => foo.Add(It.Is<int>(i => i % 2 == 0).Returns(true); 


// matching ranges
mock.Expect(foo => foo.Add(It.IsInRange<int>(0, 10, Range.Inclusive).Returns(true); 


// matching regex
mock.Expect(x => x.Execute(It.IsRegex("[a-d]+", RegexOptions.IgnoreCase))).Returns("foo");
}}}

== Properties ==

{{{
mock.Expect(foo => foo.Name).Returns("bar");


// auto-mocking hierarchies (a.k.a. recursive mocks)
mock.Expect(foo => foo.Bar.Baz.Name).Returns("baz");


mock.ExpectSet(foo => foo.Name, "foo" /* expected value */);
}}}

Stub a property so that it will automatically start tracking its value:
{{{
// start "tracking" sets/gets to this property
mock.Stub(f => f.Name);

// alternatively, provide a default value for the stubbed property
mock.Stub(f => f.Name, "foo");


// Now you can do:

IHaveValue hv = mock.Object;
// Initial value was stored
Assert.Equal(5, hv.Value);

// New value set which changes the initial value
hv.Value = 6;
Assert.Equal(6, hv.Value);
}}}

Stub all properties on a mock:
{{{
mock.StubAll();
}}}

== Events ==
{{{
var handler = mock.CreateEventHandler<FooArgs>();
// Associate the handler with the event we'll raise
view.Object.FooSelected += handler;

// Raise the event
handler.Raise(new FooArgs { Value = "foo" });

// Causing the event to raise automatically when Submit is invoked
mock.Expect(foo => foo.Submit()).Raises(handler, new FooArgs { Value = "foo" });
}}}
Moq vNext (3.0) will implement a much easier syntax for events:
{{{
// Raising an event on the mock
mock.Raise(m => m.FooEvent += null, new FooEventArgs(fooValue));

// Raising an event on a descendant down the hierarchy
mock.Raise(m => m.Child.First.FooEvent += null, new FooEventArgs(fooValue));

// Causing an event to raise automatically when Submit is invoked
mock.Expect(foo => foo.Submit()).Raises(f => f.Sent += null, EventArgs.Empty);
// The raised event would trigger behavior on the object under test, which 
// you would make assertions about later (how its state changed as a consequence, typically)
}}}

==Callbacks==

{{{
var mock = new Mock<IFoo>();
mock.Expect(foo => foo.Execute("ping"))
    .Returns(true)
    .Callback(() => calls++);


// access invocation arguments
mock.Expect(foo => foo.Execute(It.IsAny<string>()))
    .Returns(true)
    .Callback((string s) => calls.Add(s));


// callbacks can be specified before and after invocation
mock.Expect(foo => foo.Execute("ping"))
    .Callback(() => Console.WriteLine("Before returns"))
    .Returns(true)
    .Callback(() => Console.WriteLine("After returns"));
}}}

== Verification==

{{{
mock.Verify(foo => foo.Execute("ping"));
mock.VerifyGet(foo => foo.Name);
mock.VerifySet(foo => foo.Name, "foo");
}}}

== Customizing Mock Behavior ==

  * Make mock behave like a "true Mock", raising exceptions for anything that doesn't have a corresponding expectation: in Moq slang a "Strict" mock; default behavior is "Loose" mock, which never throws and returns default values or empty arrays, enumerables, etc. if no expectation is set for a member

{{{
var mock = new Mock<IFoo>(MockBehavior.Strict);
}}}

  * Invoke base class implementation if no expectation overrides the member (a.k.a. "Partial Mocks" in Rhino Mocks)

{{{
var mock = new Mock<IFoo> { CallBase = true };
}}}

  * Make an automatic recursive mock: a mock that will return a new mock for every member that doesn't have an expectation and whose return value can be mocked

{{{
var mock = new Mock<IFoo> { DefaultValue = DefaultValue.Mock };
// default is DefaultValue.Empty

// this property access would return a new mock of IBar as it's "mock-able"
IBar value = mock.Object.Bar;

// the returned mock is reused, so further accesses to the property return 
// the same mock instance. this allows us to also use this instance to 
// set further expectations on it if we want
var barMock = Mock.Get(value);
barMock.Expect(b => b.Submit()).Returns(true);
}}}

  * Centralizing mock instance creation and management: you can create and verify all mocks in a single place by using a MockFactory, which allows setting the MockBehavior, its CallBase and DefaultValue consistently
{{{
var factory = new MockFactory(MockBehavior.Strict) { DefaultValue = DefaultValue.Mock };

// Create a mock using the factory settings
var fooMock = factory.Create<IFoo>();

// Create a mock overriding the factory settings
var barMock = factory.Create<IBar>(MockBehavior.Loose);

// Verify all verifiable expectations on all mocks created through the factory
factory.Verify();

}}}

== Miscellaneous == 

  * Setting expectations for protected members (you can't get intellisense for these, so you access them using the member name as a string):

{{{
// at the top of the test fixture
using Moq.Protected()

// in the test
var mock = new Mock<CommandBase>();
mock.Protected()
     .Expect<int>("Execute")
     .Returns(5);

// if you need argument matching, you MUST use ItExpr rather than It
mock.Protected()
    .Expect<string>("Execute",
        ItExpr.IsAny<string>())
    .Returns(true);
}}}

== Advanced Features == 

{{{
// get mock from a mocked instance
IFoo foo = // get instance somehow
var fooMock = Mock.Get(foo);
fooMock.Expect(f => f.Submit()).Returns(true);


// implementing multiple interfaces in mock
var foo = new Mock<IFoo>();
var disposableFoo = foo.As<IDisposable>();
// now the IFoo mock also implements IDisposable :)
disposableFoo.Expect(df => df.Dispose());


// custom matchers
mock.Expect(foo => foo.Submit(IsLarge())).Throws<ArgumentException>();
...
[Matcher]
public string IsLarge() { return null; }
public bool IsLarge(string arg)
{ 
  return !String.IsNullOrEmpty(arg) && arg.Length > 100;
}


}}}


=Read more=
  * [http://weblogs.asp.net/stephenwalther/archive/2008/06/11/tdd-introduction-to-moq.aspx TDD : Introduction to Moq]
  * [http://translate.google.com.ar/translate?u=http%3A%2F%2Fwww.gmbsg.com%2Fworks%2Findex.php%3Ftitle%3DUnit_Testing_Revisited_-_Die_Unit_Test_Evolution_mit_C-Sharp_3.0&sl=de&tl=en&hl=es&ie=UTF-8 Unit Testing Revisited - The evolution unit test with C-Sharp 3.0] (Google-translated)
  * [http://www.nixusg.com/post/2008/08/10/The-Automated-Testing-Continuum-Part-3-(Moq).aspx The automated testing continuum]
  * [http://www.emadibrahim.com/2008/04/04/unit-test-linq-to-sql-in-aspnet-mvc-with-moq/ Unit Test Linq to Sql in ASP.Net MVC with Moq]
  * [http://www.bestechvideos.com/2008/06/08/dimecasts-net-introduction-to-mocking-with-moq?query=moq+screencast Introduction to Mocking with Moq (Video)]
  * [http://geekswithblogs.net/liammclennan/archive/2008/05/09/122007.aspx Comparing Moq to Rhino Mocks]
  * [http://www.hanselman.com/blog/MoqLinqLambdasAndPredicatesAppliedToMockObjects.aspx Moq: Linq, Lambdas and Predicates applied to Mock Objects]
  * [http://www.goneeded.com/javas/articles/20080324/a1811942466.html 
  * [http://weblogs.manas.com.ar/bcardiff/2008/04/improoved-argument-matchers-in-moq/ Improved argument matchers in Moq]
  * [http://www.madprops.org/blog/moq-triqs-successive-expectations/ Moq Triqs - Successive Expectations]


----
*Note*: when you need to pass the mock for consumption, you must use the `mock.Object` accessor as a consequence of a C# compiler restriction (vote to get it removed [https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=318122 at Microsoft Connect])

Head on to the [http://www.clariusconsulting.net/labs/moq/index.html API documentation], [http://code.google.com/p/moq/downloads/list download it] and have fun! Engage in the [http://groups.google.com/group/moqdisc discussion group] to give us feedback, share your experiences or wishes for vNext!
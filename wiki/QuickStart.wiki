#labels Featured
= Introduction to Moq =

Moq is intended to be simple to use, strong typed (no magic strings!, and therefore full compiler-verified and refactoring-friendly) and minimalistic.

==Methods==

{{{
var mock = new Mock<IFoo>();
mock.Expect(foo => foo.Execute("ping")).Returns(true);

// out arguments
var outString = "ack";
// TryParse will return true, and the out argument will return "ack", lazy evaluated
mock.Expect(foo => foo.TryParse("ping", out outString)).Returns(true);

// ref arguments
var instance = new Bar();
// Only matches if the ref argument to the invocation is the same instance
mock.Expect(foo => foo.Submit(ref instance)).Returns(true);

// access invocation arguments
mock.Expect(x => x.Execute(It.IsAny<string>()))
		.Returns((string s) => s.ToLower());
}}}

==Matching Arguments==

{{{
// any value
mock.Expect(foo => foo.Execute(It.IsAny<string>())).Returns(true);

// matching Func<int>, lazy evaluated
mock.Expect(foo => foo.Add(It.Is<int>(i => i % 2 == 0).Returns(true); 

// matching ranges
mock.Expect(foo => foo.Add(It.IsInRange<int>(0, 10, Range.Inclusive).Returns(true); 

// matching regex
mock.Expect(x => x.Execute(It.IsRegex("[a-d]+", RegexOptions.IgnoreCase))).Returns("foo");
}}}

==Properties==

{{{
mock.Expect(foo => foo.Name).Returns("bar");

// auto-mocking hierarchies
mock.Expect(foo => foo.Bar.Baz.Name).Returns("baz");

mock.ExpectSet(foo => foo.Name, "foo" /* expected value */);
}}}

==Events==

{{{
// Raising an event on the mock
var handler = mock.CreateEventHandler<FooEventArgs>();
mock.FooEvent += handler;
handler.Raise(new FooEventArgs(fooValue));

// Causing an event to raise automatically
mock.Expect(foo => foo.Submit()).Raises(handler);
}}}

==Callbacks==

{{{
var mock = new Mock<IFoo>();
mock.Expect(foo => foo.Execute("ping")).Returns(true).Callback(() => calls++);

// access invocation arguments
mock.Expect(foo => foo.Execute(It.IsAny<string>())).Returns(true).Callback((string s) => calls.Add(s));
}}}

== Verification==

{{{
mock.Verify(foo => foo.Execute("ping"));
mock.VerifyGet(foo => foo.Name);
mock.VerifySet(foo => foo.Name, "foo");
}}}

----
*Note*: when you need to pass the mock for consumption, you must use the `mock.Object` accessor as a consequence of a C# compiler restriction (vote to get it removed [https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=318122 at Microsoft Connect])

Head on to the [http://www.clariusconsulting.net/labs/moq/index.html API documentation], [http://code.google.com/p/moq/downloads/list download it] and have fun! Engage in the [http://groups.google.com/group/moqdisc discussion group] to give us feedback, share your experiences or wishes for vNext!